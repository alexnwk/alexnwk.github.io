<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7ca9cc8bf0108d8c72d91b76abeed0a1c1d163817dab793c2c359bad95944e30f37e21b2b98e265283f7e95021f12c2ddbadce160f6eeddd93be1cb7c71f115cc65e6b07723bd8240f6ac68b065c780a304892d66feb36ead9a757393a03944bf088dca60739f5875e7bc822d9f2be7fd06e3f5f8a271a57e5667b85323706ea04850404ace4a4bfadd14cb2cb99a70ff084f30ca765e7d9e271923d676efb2873e48b4616e87ad31b3e3d13d20a8127b5befdab904d8eb6fc0956957caf61b8ce57bc0aa5745ea0bd1806016e5bb94258025f071f16e8d9c06d1e416158875da2d75e406502b5ac313e23c32ef719a2d99b39b28938d4b97238986c248b03cea542ee859285f0e545ed5c4fb3de71bf3d6a2373dd6e04a0bf0a7bb30583b3d1b84f3d81ef886311a9495749031469c688b26c20af638dcfd313266cb065ccd9cdbfe08100de9de504ec424680b4b3d3bd93cdc2e1d397223b4f9fad5e7c83f16d01aa236bfc1b5c9193aa5283b6f1b0e515010e956b6afc81853410cd9f9775385dcd338df1613bf145b2f002faf37cf4d0b69fbdecfa43e0affe2beda294c4a602d3f813d465fcac71cac92c9358502e824fc07e47121483ab1667c29a47586e0bdbb30a4398dbc3bc9280d013deb52d7d05735e4e54ec714ca072dd87d2d49353b27c7e314d5b9891335b9030d44b05f2bfe4e57c899d975d0287837ffec6e3432e4bbc45608bd33ed86e35f409719e6a5d0ed5521be41a2ec68b0d7a0c5109b46b90040177f65b0d494b42e89744752355c34ae94b4cc11301f7f70e7055bfcafdb3575ccbe90c7f699e4d2322a3252c2ad817d474c377b862a7319abff7c0faae2b6754bfabf5942128165c4a3febd57da9f0ef135417c9301a70874c14362b92ec352f81f0bf054ce5647fcc71890b25a75d3e76005732b0c92009aa334b3205f487c115ce2945d879a120c26f524a891c07614ba3a62063ddfacb317468a1348134f501d21242943f56afa655f640f6a5101ad580aa661b620df0cbb81c17daa2fd42d80a12fca87f455bfa7e11037935ff1a894fbef76f8980edf4330d89746d73240654f553c42256151b579e04b1d7f1273e538fbcb7d85c7d4ebe9d9ebb69363cb1a1781f94729137117776a22d26d0b7fde7f39c623d644edbc244da44b1370e26994d39eb1e0edd6d3f551c01dcdf6ae0a7d4c23de6738ec33bc99790b459e24c4796a21ad1827a739b547a7316d9c16f9ba338c7c9deb9e80ab7f9fc9cfbd2a9bd765bf5e67227c0c681a62fef916b38ffb076212c181865c53365d149ff9b020693c7a156c78308c0e5451a3967660d90142acf5b22aa831d9a3ebafac0d19dcf0d68889ee2e95080be01b4519a56dadde23694a6d33f8bae95dff51f88d9747e784c9a89029abe1d1797f10a711f8899246bb2e3f5856dd9f2f25c20f75e70b77e6660c98d57a54cb8cb49d6e4ac96bc957a4b21f8f4e5975f36ad5c59335adfd5043a446916cbf5b6403fb98d8c437f0179ba99bb6da5c6685829bb0e142e62e1dca0fd1ed415ac86a9f8a290c94171934c418a74247df22f457946068f23fef305884f545def8c7b238ebc2745487563b2bb1846da51ca7a758ae5d7efa6256c653169e34180ebc5f0623da09d8444c19bb07950f74cf067e84e6ebe9f38e956932b4bc755926712a70ef209a89619d76be8d5808ccff28496321d703f576945b389699af334bc322898579da6014e15ffecb461ff431cc1aa72fa7f473e790c2b1a51e9bc46850cce512f5c4b6086bce81263127607e69a60360d371a0de98c2cad7373cac7753853e601943f92c4710f4d9419c69d4344391f63854f92f577618c457e095b12f933df3216b152fd75cc2ed7b8cec2e8beea440cce145b28fe26d289c5a1cb75bb23e17dea443c0ff677dbccda158a62cbb831e81d9561be40b73fc9e5153500b36ac7c4ac3defec6783f624b29dba61ccdc67b460ef3cf12ef9b79e8a841446870963a9814813fc362784142c61959e27df298b667d2933035ba74c3d03ee63bcb7b16d642db4191bdfd51d8252342fac017d8c831ee6f56c907fc4be8b7565959b34db4c0d4fef15e0bf218f72f3594164da382be040c7ba262706a789e4627af98ada5ab944b49a3ce9bfa15712923dfacb4401b515093777203f8c34f95ca9a38baf519de5f8e6c3a72190a349b28e639bdf7f68b1bd6997fedaad0af3cf86393f16115fb19306e6616654890cc5c36f5002df49ee407b05d1cd7324082fce1bb3203498c6a5f2b0069ed6618be7fd9ae3f3ab9901fcfa7638adba523cbcc71266880fc8b2d80690b403cfd7a270c5d006bd60a54224c67520a416033591c8133cc5c2a30fa2f40140077a5e18a383a94f3da4955b90a835e91ce32f904a714421f474c6503b3a62185c0fa882b2c7fd58100b75c206994c4f66edec48f84eec780d0a9c4d556633e90f91777a8b675b54499921ac63a927336bde74c4cc00601b448c98ad7a90f695ed12c9da1ddff3e598f64e35c96e2a8b0959cb3725943025aa63bf1ceef51326bb4791cd49f5fdf671e30ea8502589365a132a49623013e4a982cb436d9e111d1fedd7b1b92dbf1421550f9726d25805089b0b0a8649158bb3049f2e26068d9ad614b528714e54f571e5fa88c5d3817472439e5fac1959a53a4357f50ebb53de628aa11d58447256a578cc73614d8d801d15cebf1dee42b670db3cfb39a9376a114c3abbbc1768f603bfcaed68c0f55f3c6d57f508e0da7a7b71726eceb343a9f9326bbf5cc4c777233e69578ee133ac65b906c335343426e8dafdb9851110822d769de9cc222f61b99d1881a8301904f79e22080bf0866a68a5f1f31b66de6b5837c3110dd87264a6eac0fd22f3a8a1e091018ba268ff6e63c5441a87d746c8c48c2a171506a0c1efe1a041f0f0d91579b13d49088ebe6c15c30dda8a56ed4ed204be5cc6316af414eb43775319144299f1c463e3c66443e1ffd9b69e9e7a1f7448d08bd80f6d4d37d5a5199ed8f132e0f4d6cb13bf34a383f0a21822229729a4b11792e9ad8da1a9ecd5858aa6d67c63415c22cf151d6f55f928d5797add992bb68a1767a25e79eaa4a738d110a5de260363069e02af18f77066aadd6b2537a7b591b695f58d2832c74c39da46f56845d70eb10cbd46018bb6d8eead0a152a881e35456e981eb386f1236219fd6308f1aa2fe0b4b78c5b6d5afeb2f52460805edfeb0025c857eae4791f42ed54586174133990219c40ae8bcb91f7b2ea40e94df888f7491c7697c811d0151160ed9eb3deb73b16409b14d062ec2dbdefa21a1d193d20a8acf001e1f10e1b8299a2fc1902fec5a00f76ba9ee0f46b24a09ac8c388d603f4523e7a9c0ee86ac30be729337cc4773f6b186335ae1b3e295d9e0b1537ba4febe7d1927b697cc4a818b83f648012932b3c33f6593b2fef2bde362ed93c45068b09e77ba186a00954a34d2ce8171ff5d156927d0cf296adc19b30fbb9fe5bf764a5df7f1e9e0ff82295c1cb13d42039c9a07f72b66294938ff287afa0c6344906fabfe43cf48806295fcbff3cf4dfa63a68ba7117f65e42316b0508786645b452b6ef707209fa83b6591929c54f17e08b0b97260126b5c8099698320130d95816c4b484a561f17dbebcc2a9d02f6e2ce128cae0ca9b3a61a325c3d59b3506660c7181a004a68ca1a3bbaede3c67f6c2b09a62e8fe0de679efaee88e6ddc956a01438659ea926316432ef68d1b525b8377a4c9bf60cc401ef6c83afa51341393265a0110b5b0e98e79ce820528d9b254d7b4ebc8dac314d16fb29395bef6edc355ccd6acb43562ad2eb18de19b4537cae998c0cfbea3d555ddccb903c03ff1a0dc18b72753f46e88864f2c0224cddbd68798a87c8f8ba734f8bb04ba9d6bfa73a9606c220362dee07d77a8f5ae32bae8337af3ce728b6da347a104b4cab043591bdf2080b429bb8fd1a805291c61bd8e9d836cf81a1641b28a479cd3ce92864011ee5feb834b288c1046415c7f0f5ac0019698bec3d18d921fe51b46129a27459d10ceaf79e74130285d5f7974ff25644ce8a0eb78b748ea2a2db9088fe4e0cb07a3f19edade1d24b414c6f405076c5d50e8ca4c3f7f2b62dfc1ddbcc7ee2d1122710c86c3a8e6a661f9e9b54306042d6774f425dba6d8dc7904aab40d1bd9983740eda0cfa8ef55d46afee6f8334144cad9c7f32e41a8f6a25bb9bac4f08e7a55b3e0d8488d7c15092340addb3d717e76db0ab1b461805d4f92de32af8ba58470138038fdad20392cb2f1ad171c9f72fdfb4e7a310f4aef13e30b348bd62a90b50854370c5e0b767138295002d841718c3ff0997bc094e2fac3f4841d05174d2461c9e624c502f216223631ff0021cab771d46cf87c8aec72ef79b0844641839614219f51d13c19abcb04c7a6ebb9af465ad0dc9fea0a4f9f6fc64c8e950d93606faef92da280976acd48b39439d099fdadb3e69d1e184e22e122b3933a7c19748b9e21aad87a403e97eb9a7e73c8f12614c3eb7c86e7b87d74769c44b23075f0ec05d606928593b70d6b3ec02b363a1d98d06c6d2133e96edfcd8c5388f99e9f848476d06b81b6f8b93734d003734c435a2fde20ecbd67d9a81fb8895fe8f97b972887e2b175d382aabad4e36b45c9d170a4eb29a1fed626d9ce0b5d8ff8fd0cfd10ebea31b33fa24ba946a2bde5a221e82c5f299be3b0b6f28410bd985fc2911242db4fc299b18c7d34a0baaa5269378a6fc984c0e566ad21bb7908b8b7ec410e23ce0b6162728c86546a6a5d437580249b472bc7d61750b5afe12300b0a70a6aae91af6bb11bee6fe95cd678aac805c677760b31c9df9b0fd017678f4545bab5cab51752f31543e6a5bb7ffadb13c63d6b0f7f32ec833156a5007fd4ab9347cbe40185f2cb06a9d4bc9f8ca51a3119d6f95523d3a5f50470b7f15544c24fb26b93ed8bfaa50953e30c2e453bcaed265557dc43417288fb13af853e06cb04918aee0c17fcf2f8a27d95a02fab1a9aa68ec1bf51bccfc0fe4411959535c06e347725252bd0d727393aecc5d2035e0e292a9df0ab8648b110f6da335dd9355652ef98e757936c87f0366da77fb865ce4ee51a62c3a3e2e0726f775e7990ed0ab528f3c1fabbe78fb6843e998465e949304351203518c23c56da6fe80d88c409f220a1166316f8c149fd576e83dfa6e9b5ccc7723c4b64a5753c2be34de21d37872c8a015d445a636df5809cb64622fe02b70ac44f34dd674b23441cc87f3e828b520c828ef943b2e8fe7ce6642d6c4b9c8ed7f810a1217b6e252492cb6d6b11a7dd4916d1f18d3d76284f38eb9b85b3f79ec12535efcdcf717cfc56dce356bf857e911230a6367ffd770b9f398fb9ea8fc708b9ff4ec2f1b03c3aef9740aaf208009448229ca25394482f84d847be20297b59fd4664877d194ac4dff98b207e3b663c0bf6fe51f4e5774735aaa27862d3831a8fe593cf06cebf51e5275186cf494f6d4ad6b1128ea11b0ac05f85ef2f5f92cc1c22541c638f3bc8c1ae1b4ed63da1a429a128ba628043f79d4e0dd30abdbfaa1b57e9f898e57e6818656d176c74eac1632d716910485eb23bc0c013c87f5ec005b481790d83ce11f7dcc86aa7ae8d182c3fd8000dfda25c826c6bce0caceeac4fa7e9516c66478a1c6dc7074cb353f0cb4e589f25e97607eb55837dee900ff1727918a0f62700951473b2d6e77e5c87e81770ddaab99486f2cd4b7b2a7e77ad8c8f2bfd932c8cf5a9892281b86dcec510c8d1ed9cee384cc7babd3216b0e543447ed7ece17d2aab2b78de0d919ed323a42a8b16106715f6eac9c2d056e76a531e1d66557839d9a20c44420c5e914289b6658a6688b95fb446f69648d555b05c6a15411589d14bb803b139f258f6ca796768a07034b426e4b6435f017a544629af462f72cec978259ecca19b9fcf2e0f93c69c14a2eb28693d3220ea61324b2e7f29c3c41ee3a14a7a6f25e4181db830e8b1fd2210553858dd6279ba3280c6c3051836fd6b0841f57d4e2a8e4bfd09269ef89b59cce1f3e0a04a953e6207a4df2bc0e479335ba1b22b25b35afe1d6f4ee929d8bf3fde063dd1f696ae48c85d46322e856fb34e1289851be81a329e831f34c96c614a01811f2f20085fed9237155a302436e1946bb03248031234f1adf0fd9cfaf9c9e12f40ba4c6ceb71133940a4435a2e45d0935b9953bf6f2010b534f7d67d81c73b5bd6ee36787a04babd5cf833c499bf2a1a98c0c142b6b31fd7475a472527c8749785a3f44c1d7d3eb58f52d2e92ed0590b3bba9cb4f56b0ccfdcd4dfa653add1e6b47bd175286a6dd829af2453fd8fcb310fd6563d980f5386b4e3735b22a394615de3ef0b207cbe2aaf05f4c9c6c84ce20435c0fd23eaeaccd6261553452ea1e4c28ccef2d8cae95dba60e56c1e4f6e214bc2a717868dd61e23f8e056fabd1e309135566286e7cd0babdd23556e395f4a9f7844ebaee6aa19996202b827e8e4dbd0c86535c580eed6c8561e418b9eaec9692e36c3d52b86c48d1ed61aac7ec932456ac42fb2aade3b2534ea0d1415e97834ba98d6b1fc5fd4cd3555e97c5f6454ee949fe57c7e2c7239b4871cf58cc782bd946d1685b8ade8825ab02a6272d723a2add009c0294f2875a9b02e4edec851c4f772b3703c5ea171cad78b2afb1422d3286d742c098dff9bd14954c7d8d94ddf56f3cc433697ad1213d6697407a28ee8c03f5d4c6797eae192f30ede07bbc99889171c9a3f04b3010e3d80768e78bb812f220ae80b79cea5c1b4106acd69941f98eae260b1fb6a2769c7566d55924b4dd3d4a2c6ae55615dd905e407df344c951c4cce8f055f939f3e95af03988f8e007900aac403dbb4e04ca3798a02dcc258063d05a44a829a75508a106ab9e33a3f7ab41ae20c84d0efd65633ef313beb18eca8ee074a3c6f87071db21d69d45930e64d723dae3e25f45ed87fdcc1fbe38964676146b6e776e60a98360ded731773c6c15b183337e0ddbfe78f8802b0b9e3fb11cf0c999e25f328ba1880d78293f626681ba8cd2ceb265db729b4dc56e067d0ca3d22bcf269be2ef87960e6d1e43343bb9fb35b716445987c9963d1a961044367bc2a01b69fe8f7f8ece11f1e41bbe1e59816380c0695d8925a174de24c316f244e8ef976a5811f6a64e75582bb6f38c8211bec315477fcf0a7e7b22f48ec0c59c7b3de409cefba0c1a805068a912eb9ea2cb9222b75befba8d15216bb989ea91d8edaa0083fe5bdfeb194b9104df1180fb0bc0c69aa8281c00716d2146d6f30f67f4b064e68600f81db32a1658ebbae91b4fc3a96af1dca532bdf0877c370f005cbea3651af979a54a9687c9354cb2cab5694ebab4ee65f74fff6434b418656b09e52b66c97cd75dcfb138b153e4dfb552fc759142a74ceb24b5dab05ebd3ac17021f1c3130b697eacb03e861302a84ffe24f281e35bce030c7c20fe7ecb35bd843f6ed727cfb81ccad6079d2905d977ec83403d2d1e9181dbf9990f92b8dde94975b1b705f36446fcf44c63ca6d93e25f9994ec30f6654f133aceb56a699fe5650f9674772b75f10c7ef954a0f8f3fbcfedd94a2826a3f737290e346cf2b646cd9be42a1850e20670ac43ba43542e6587440024489f2789d404ab0ee750e06950dccc4dac23feed245ce1da8ba7dbc75fb9a2c97d74a9ddae91226c7179ba229eefe345523e3384312a997d6aa259576bfb18598532062f2d035d5acfa6222727e425f2072c1a6dad9ab7af5376c477017635af027e561c4cb59af0369d7bfc5e2cd7a269bdfbdb723204515526ada43cb53901","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ea5012154d40db0bb1d59c5d8b93834a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
