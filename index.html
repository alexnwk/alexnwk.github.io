<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b33ccb518721ebdacca0b3ae6aa3c6de7b11e4aaaf4d2e3477ccd846f43b707ddc57c426d29bc9b34bfd89c7841fb93f23fe51c5965f171a5fb2a394e314e80120fc1ac4992079994d454af9263f66885a660829bd126f2675d523711608421361fe008ad5608e6ac4f5debb5bb584206090406585769792ae6aeb1981e1211fa1695564f9b1947e474c780ad66459175c3415d6840f827bddb43d9ba208b6d9d0d3e05b7e09b96f6525993ed027e7701fef730fe9138208b22ad415599c3cb82b785e86840b4bd2d44f363b6c52184cf080352bd4826635f7625b75559fec29d510dc46c5ec5c7031191e94660bb18f2b612ca6acddf1fb6678eadb8c795c83a813ef9d1164acfb7db832401d08de5d890e360a4cdff37f52bac0e11ed2d94f3be25c8ec1d76fb46adc8db9f12124c3473fd4a7c86666e9bd41d2e8aa0776b4b00cb8f70df9c8c19fae48f2fd1449dc6fdc19802167c084e6254dbfb9956c73888c3c60c449fb71175c29009c06f2ad547f192370cd5fb87d85a83e130f3f4807e37d99a6daea8a4c72c6b13e02e8aa024463a35a6a5708825848c1da50e7ca549cfe1abad60b94157aa860987b5920a9c6c08e77cb9eeb17f00302a2d96273e514a2494c03a3d02cc4c4fc56dcd3d9e4de50bdc81a6fa37913024d05419d9abe5a28b63745f26912da99b55435d06abdabf10004d2f4700e28bfed7ef0734ec852a053b304619847372b81436acaa36445272c0d81c2fac655617e6b477e8d15a50803e2f501def1c3689e0f718ececdfaadd0ee0a3f1f2852ab34c6e4271c6a76fd8a4430cf55c497f9f8ca348f47b94f0fb0f254d2627dff773f18cac6e1f85df5ac31282c4bebbbf0767f1a9b8816ba131ad868e9f8ec8563a122f9272591b79f1584b9fbc6ef9d46601e53e63438f57d95914d700b908b3a89197401a57c77192a11b69c240efdbbe243c8b27b0d610f8a88954553f886c00ed2771d78f75f31bf6dc132f0e6264c119d288e4f06dc58f59308df4f6e6a55a47af1c4644b0f0533f3c438454d9d5ee1def1c0704079bb706d27bedfff5ec62cf0c07e6f7c7992f8a3b160f586610e2b08fe9aae236be2a6a4db04f56b5ede4aeb9b75813d2c1c59389a6c55060f69b981dc90783b91a0d5524274fc6aaa27436a2c36efa14913211b61b60581e3ba4a4dfd84d41e53324e68d2578744994339eec85fa77c9504b06a228b0e1046139cd90e6068227fccd10c62e1807cd7fc4f5683c88b9f649cccb9a47d24891f8f08cc320f5ea672f6ebfbaa6bb42cb1e2f5d3754215e89188fcf6a2004b51bceac3a5574d326c87ba57d2f21265dcd493c85563b0278e9f1e49549f29fb76282b402fbc465f9e9b1f4b7305a852f2658b9d5856f46ce401526a20f956e2ccb6debdbfa8bda7a0e89af821646f3a0cb83c4102cefff70fa5c244fc78eae089ad83574421bab835f8c33cb46920d3038179a65fa51f64e625ae3f2596093e88aab39ef293a63dd1d1d21cfb07bf2aec1a94c91ffe170cb38ba89a01e75b031755ec77eba4045ebe17de8ce53f0d04ff930e23bc628ba983f44ba171cf60632624b2d10d02137100b2eb8ee8bdba8ad800845f4dad1e1c251ac18c3b68d6d7f15e9ed0ce03fa1ef6dfbdba24b9c9968c5fc6276e343b43e71de284efd56eb412b856999456b7b74cb9ac8bcae14724c567e2fb016bf0d0d3aef5c4144fe1d858fa2d512adeb78cb2f081bf7a41a25b061c14c1159a721f3e94561542c637c778bef56c56a1f5126f425514baef07eb99db9314880b0987ab4178e3e70a5ffba4c0c8d5c44b1965badda1fe0676675b740f48fbc0d6fccb193f9fbb9c31e1f15885add9180ed36b6b1e2701b7b86a59818c997d75fd1d8e0e5b001a240bdae0fb1dabcb360fc48ba0372d1ed78664fe37adfa68455f49787341260959f2f59a1cfa6246e0c7f49af53d65a036b696a09e0e74d7425aa8879e42cc8d4d0d40f0905d7377201efeebc237d1cfc65c5daefe4f51b67306e3a2a996eca1c81900e40c3b47e5c9d7db47d752516484a4f6e8ee3c407174385a231d26ebbabb9334c2e6c59ccb4834d1de0c4634fc078f5a16e9996507312b8b3600ddf96dd0825e211f6d1d22659a452c7a834bb75dd953063003fd8f6fe4427c65b3d59a056c2bb8598c529a52971880c92440d75bb4bf5b338d770f0fac63e3ef0ddcd18b7d513bc6a5dc9ffe2e7d0ce53bd3d24ceba6b230f02e4b92c9724d2fca61ed16b077c74cfc34048915af02748f0a9116026149ec7835604d926525a885db5d588aa3a023c96eaa27a43a73f24af75196b1b24f5d3beb03cab221c857e8733f740da5fa0831f7e14d2a117a9483588a53efa3d37487cddb1b29bc729f35c164eebf4a28f628d920586498d601f94dc93a5aa650d7237f52237ea1ada32d9b4fd86bfe0d94be764c940719fd7a75b9d0b6adf16a2ed2c912dd3eeb145ad4206e3212e784df4cec67706fa29f8539d5f1bf9489023ef34f2bb67ce940c29ca978541c58c57638769be8259fb740c7d631cafccf8403a133e8cdf3c5e9675682ec83a3d6c8241cbf208042a21ba158aeea840743d0681e8d95b3fef1fa01e79cf62b77db7dd7c7980f4ac24843ae503c88bcd61f67545f69bc6abcd7205ee0544b9ee607cd4fb4af6fe265dd6beece79e35aa4f198545bb9d00c1c028d1ec9077610c05df3bff740d6ba2a68a060868122318f1c88465833e345324a93b7877099c7d58e1c4802be079d49501369ee84f408097f63635a1f03503379b4b69de3b3c5362de43a8917843ce58bfa9e0601d3499cd0de1aa321caa0965057efe242a3fdf39a0a4c3ea0c4009ca71cf0cd37e66d89988ec6b3cf454f3a11e6b2275aa4a04894555190a033ade523248e1868af3c37b554e29bc3de121a7e9e5ec0e3c1115a4f922b0690be13822d8e23596fa0f1bba43af177b88cc6c32beb2069c1a22853f7600c378ee4f532a6423b8a7106b8cef4ca0c82211a84fd8a8379b3c44d1816686fdf394c1531efd5f148a48f2619ae838b2e584b19fcbf6299b4acc0b1e446e6e459a52dfbb22b55a7a6d1ace004c6159c9d744f53a66868e4d1651de27fdb35322ce9f602fdd72feb55f1d086dd78fb30c9c1e9fc809e3200b2f71bad4881e9cbad39e2c2d06c8f90112a2ecc3d8496075c802c0b0f0db5ec1e4842c6eeb1bf138ac3814880b6448d9ffb77b053b8898a8484c7e99871332afabd686f397b62ab7fc1f9cf5b02f05db49841bb814cecafd5ed0fe27cac4105bf0641c2bd0b71465006ea9a6fa7066b6df8db97f386bdc86813e540487880e9c65ca71a5532238b3c0c989677762b5dfa386b93c27ba8fa09732f72588cf67e1a7fb591a42da0f3801b1f69f62497f0351cf1b3a88c12878a23faab7c3073f7da6d96350941a2dbcff4cda1215226760b60ed7f74eedf6471721ca3478bda41f9630d24bfcddd542fdfab88928680116213092f5a8b4f8dd98fefa6805c609a37be551aaf120a568c5297cfd30aea9569d14a8d8aa241d945ed3c2c79771df80301b22327141c0d886ce3bd4e688376b0d1bd6aabbe822717a68bf506bdb3762323ecbd7eb56608eb66adc316f5bf330a75e244a0e35c973c0723cd39de91b4a8514dfbc2ae03d0570987836e13f4f5014f51629c7c15b8038fc318cccf5e130baf8abe9bf8f332b6ee56c4af0c529a738ee1a32ad686b7befadfd530a54627ac9748d2dfae5ca111d7055bf3cab37ecf09903caaf458e78cd7b7dfb9c0770267b8618a3024d7994496c26983494505881842a83b4ab793ab6325c5ee8245a2859b45de27fbc863872efd909126b5092cc93854a357cbb9d26f2861f9f1233de910f5fbf49efddb9b1e1dd35ca9ba3237c195bc717a5c6ed3e1a3599917bdaa67eba387739ae93d8d68336c939b8a008cf1c7541ac751ce88afd00fb7d473250e59f8a48fbf1a17538fe02b9b6d7786f18aa856fe76893b5526e2d7243e838e4babf62c24b4cf66d0fb602daa6cc3326aea542a473aec96ae1d22a38e540b97b5019af466a050c63a66245ddd0198e37201849e6fc72e3e8ca2089bdbcbef7d4685672588cc68dc7175bb3be389b8b38a7ca029eac93b867fe992f7bb8f152641d868e1f10471b1f57be2d90fe32ee8500d44ad0ce41e134360550920cdba81206d4fe8d6b5b04c432b8fcdb481a96dbac5185985c1c09fe6f90847834a56e1631083010a092dba5c04da63a0b9d19d12ac61a180f02719f04c1353e041190cd38b435d68c3e77a2c894f7d8230e624e8d0ff9f77536490e718306ad86a15ec338b9b6d2942194f0b0c0c34f43fb5eb2f2c09848541fbe0fbdd0179b77e2ed67f6d81b9108598f36bb789d86b601e4c9aa970c4e757ef62ff192a71053bf3ae794f630b043c0a1e6b5324d3499290ed4888c6103544c488c0982eea295deee62394eeecc1d5b5213846e857d6867dbfc352109da1abd6f2c2816a7711b0ecce577a74b5f3722734db2306bee0d51ea8e09b8da898d489854912f3cf5f0791f3caa54bf351127f18d3459ae1d313e217c778e982bc9ee9fb67f05e710a7621b6bdba64422780b76afeb206e381be441513cfafbca9994d1fc2a7a8a1b01fd99ed8819be5bbc48284a0d006fadfba67c6b060426363a556e648219a05a6b18137f93268c48cefbeba7bbeaecb6c1c9bf28118f30a1ca2534560c99c4da217219703791fa09ea38df74141131d2ba6f1eae23cab9d437001994a5d953489525d63341ed047fa294a8383fd76051649053b8f674d0b97cf2722156acf61f861741e2fc12f8c9553a408291f889c210de16c61292ed583289f866732b0bd667bb15857d0911d3ccab33d9226a41b8a8ce0437f3521988db0071b628216d0d3b6460d6cd579bffb7b46dc7d1ba8ec629b0a596e90a0aca433502ca53919ed31219e7487534a258e1bf5b8dd4ecd1b9c6d1625e470161f82950166da6df3f105364351517708fb205e9913459c506ab143676c42845578ff9a63ad34940b862f71a8e2121bf1f42a1ea6ce76e7a69d6153db491e59e7bd92c8c5bae5bc81ab0e7c1ddc8a9d701ba36e29302f8f4ae2e533dffd38f7595010593f6ca9d76abb1d1ccd339af4fbed15802beb1859da344839fe4eeb85cb13fd638948c260599396deb2e623ee3a7b95be4f8b21b565c7a7d44df845e5bd7776db04857b8950c4a2cb5619e130290baaee5b4dc9bb5d77b798380f4819eb72522a85311aca3d240d2def38930b8da13a0caac6fc0fce578c5d4a4e2e9bf5136156e9e921e9418de71f3c5bbb789031405c8ce25007a4f6cbc3f6971e592cf6cee0acc1885ef9db4ce5dea7f9184b5cb71eaac92e792eff8dded66e37c57fcacc3e9b3c85535c005265d493b0d5c50d8c84e22ebb6c33614d37933550043b1296dced43647fdbecf8ecbe7e81ffe73baac2857665d2fca76cf0d87716562bc77a13ba76b2d931e7790b4fe09332249191ea8c7fe4e062c4be71af119c236bb34d6f754745af74dede75b217b78d5d7654c5af2d59234141fc17939a977a2f6bff8af2c2bcb621407ffffc2731fe3374a3a381c87f269196e8202028bff7c8b9b051d8499e02b02d74a15c3426de504718a3fb119c598db763c2b35ecad88e275979d3d665dfa3df122f71e261b7994c42c50102bba50471852da4e68bf4a8bae9c8343a1733d12a248ba8463e89aba3173911835f84c94031916507bdbcd6a9855184970159ee8df5e020eb9f95708478ae2954623cb782a94eeea34dc7719acd79d81122fedd3e9886eef7130838958916c6575e9db5cfb5b4ddc8a3bc2d6758ee767301798972eff7a93acfd863211b66477b99a06c2a8d8912d4d2eb2d83ff2600f14de47b7aca5897d8ecca1998a1fd2f19ea90e66f2b743f56a175fc75c74db2573583348ef72541ea7398ce1ba1bb97650349a1764db754614e630ed20c46dc29581950fc904d7757a4a3bde0cb6ddf82935ae86bfd22550dc98f95bb780400929e0eac8cd0b2aa4baff634ff8478e6e1286c582f87d281bf319ec0a674104877104f7571527659daae822e30f45e92d67f561b0a6044d1c452ee09daa261038865be10bf68b1791672645123585880742a3279b888ca2aaa51467f733c7a79692d13ebd86e4cf583756d080a8b0649f0e26e078370945c33032ef7cb5a5e6f90205311dbbdb08914ca964d991fe4eae867d26227d1b2f2e64647a050ab03e61777ee986397fe8b77e05f3190f0ddf5cd94211e4524fed42f66605d3f1b606ea9953e1836ab3c5e7119fa77aeabec0cd1484966fe8f61464947115624559d9d7b70adec96310000fe743ad846127dc8113d1dbc7c7398ccd4dd9505cf3bc0867c4016da8ed2fad53c04ad65d3d2c8ba45e9570ecf104c6829392c7814cb81a7b121616736c7bf86be371592d9bd7af0203b9dae47d9d1541a68b522ad5e2b19999ab8ed2af5bd6396005cb0e5053cac7ed1c7b2e7269473516a6fc69a8fd4b58bb246897e9b9c880d363e9976bccb3ba4c285dd0e01875e8b08bd4b1e876ca36a4d5fd609db110a1e1978d2417632ff253d5060e4ee296b22120fdddf6039a2dde7611a3e5842a64b7e6ef86ff1c5040fd0624654ba1879fc0b4cace0d9b573b98046b1dc17af69116ef31695a9a2e2cb1ed5b77689e800fe29da7efbbaa485a77a072afa853b55683570a77885c7d80296145c5173e10127df152dc4fac0806781231cbef1e390e3c42941582b697cf106924543404f0109e23d94a4ceadcee535b53762ece6b17261ed5416cbf854fe2c56ce3ac26def0ee5996261375d0856b0ba3b1e46098615db05d4850246ea7567a1184b3da9d9a81c3a276cca50b72108b3d58ba7429acf227fea4c8be67fbf25dfb249b4a753736dae94487d07d2b3cbbb3433339306a2a7e7185d91983c47b2fb15d0b623f6dd8813cbbca5061141e0f5f7ada5867fa73a7b009ffd6a77706adb74002fd7c49471c5620e671d7eae8c63dc3f65e3de48f65c7d3f51439d6afd3048c6c9a80d43b101c5c5f44b79681dc2940fb3be5ac03c014e6275a70a22a7ad8b5581965e8bc40aacedb8d6332edeb7675a945fc139f9d6ca2c98713b5c51bb2622925a0f952cad081aa6f84971e0c21be5f9e9df5a0268b56db7726397d16328b670ac36ccfc53e8de210283eb03ce5709416be835bfb63f26768c514340f7f97885c4e75f92a703ec19162d474867f7d73f59628d0bb326b499655e78e2b04bffec3e55e7a6d5383a32ac286831b1d88af64c3f230bea7645949bfae29735f48bb5ac8ea11baf28b95bc16bb1efd891524593580d921adeb2e718ec2416073e8964b399d23ecd2445b9cae14da40fa2c5cf5fc153a59697fa3f040d0f9621f55dbdcc7bb4d356d5f103d7a6feb2469bfc460b6ed9bbf877521358f248269cbe00c946738d9f54cbefe1a86c7566143ec2591bbb072530dd3a87b27c30ebad26740907aa92c55011720cf61a1860c6967fb806067abbae59ee2fec5cb1a4597110a72962a63439383ac8eae034d957f40f496d4e0980b8b7c78731f5d845b9872b13ddb2cacc9124bd2dd63296ae05e671a1e53bde734df381f68c407bc0688c28697aa11086d46c0b6e47521357c140bcc8805d45487dc733293c25fc2105761a452a95e471b483c340e95d2161e7f7fb6dc21862538757948b850bdbfa1abb0f92c2641d4738235aeadbe58c8446d95189f79bd9e993afb9e7eec399319dbccaab2f6b83ebf201ce00389689cbaa6d76ce1c608a4ea2b44572c16be9419a224e41a5f9ca73263fb27ceb3f478cc15a334ff06526","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5b49804eb03d1b8dd5f79fd085627186"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
